// // #include <stdio.h>
// // #include <stdlib.h>
// // #include <cuda.h>


// // //======================
// // #define DEV_NO 0
// // cudaDeviceProp prop;
// // const int INF = ((1 << 30) - 1);
// // const int V = 50010;
// // int n, m;
// // int* Dist_host;

// // void input(char* infile) {
// //     FILE* file = fopen(infile, "rb");
// //     fread(&n, sizeof(int), 1, file);
// //     fread(&m, sizeof(int), 1, file);
// //     Dist_host = (int*)malloc(n * n * sizeof(int));

// //     for (int i = 0; i < n * n; ++i) {
// //         Dist_host[i] = INF;
// //     }
// //     for (int i = 0; i < n; ++i) {
// //         Dist_host[i * n + i] = 0;
// //     }

// //     int pair[3];
// //     for (int i = 0; i < m; ++i) {
// //         fread(pair, sizeof(int), 3, file);
// //         Dist_host[pair[0] * n + pair[1]] = pair[2];
// //     }
// //     fclose(file);
// // }

// // void output(char* outFileName) {
// //     FILE* outfile = fopen(outFileName, "w");
// //     for (int i = 0; i < n; ++i) {
// //         fwrite(&Dist_host[i * n], sizeof(int), n, outfile);
// //     }
// //     fclose(outfile);
// // }

// // int ceil(int a, int b) { return (a + b - 1) / b; }

// // block_FW(int* dist_d, int B) {
// //     int round = ceil(n, B);
// //     for (int r = 0; r < round; ++r) {
// //         printf("%d %d\n", r, round);
// //         fflush(stdout);
// //         /* Phase 1*/
// //         cal(B, r, r, r, 1, 1);

// //         /* Phase 2*/
// //         cal(B, r, r, 0, r, 1); //pivot左邊row
// //         cal(B, r, r, r + 1, round - r - 1, 1); //pivot右邊row
// //         cal(B, r, 0, r, 1, r); //pivot上面col
// //         cal(B, r, r + 1, r, 1, round - r - 1); //pivot下面col

// //         /* Phase 3*/
// //         cal(B, r, 0, 0, r, r);
// //         cal(B, r, 0, r + 1, round - r - 1, r);
// //         cal(B, r, r + 1, 0, r, round - r - 1);
// //         cal(B, r, r + 1, r + 1, round - r - 1, round - r - 1);
// //     }
// // }

// // void cal(
// //     int B, int Round, int block_start_x, int block_start_y, int block_width, int block_height) {
// //     int block_end_x = block_start_x + block_height;
// //     int block_end_y = block_start_y + block_width;

// //     for (int b_i = block_start_x; b_i < block_end_x; ++b_i) {
// //         for (int b_j = block_start_y; b_j < block_end_y; ++b_j) {
// //             // To calculate B*B elements in the block (b_i, b_j)
// //             // For each block, it need to compute B times
// //             for (int k = Round * B; k < (Round + 1) * B && k < n; ++k) {
// //                 // To calculate original index of elements in the block (b_i, b_j)
// //                 // For instance, original index of (0,0) in block (1,2) is (2,5) for V=6,B=2
// //                 int block_internal_start_x = b_i * B;
// //                 int block_internal_end_x = (b_i + 1) * B;
// //                 int block_internal_start_y = b_j * B;
// //                 int block_internal_end_y = (b_j + 1) * B;

// //                 if (block_internal_end_x > n) block_internal_end_x = n;
// //                 if (block_internal_end_y > n) block_internal_end_y = n;

// //                 for (int i = block_internal_start_x; i < block_internal_end_x; ++i) {
// //                     for (int j = block_internal_start_y; j < block_internal_end_y; ++j) {
// //                         if (Dist[i][k] + Dist[k][j] < Dist[i][j]) {
// //                             Dist[i][j] = Dist[i][k] + Dist[k][j];
// //                         }
// //                     }
// //                 }
// //             }
// //         }
// //     }
// // }

// // int main(int argc, char* argv[]) {
// //     input(argv[1]);
// //     int B = 512;
// //     int* Dist_dev;

// //     // cudaGetDeviceProperties(&prop, DEV_NO);
// //     cudaError_t err = cudaGetDeviceProperties(&prop, DEV_NO);
// //     if (err != cudaSuccess) {
// //         printf("CUDA Error: %s\n", cudaGetErrorString(err));
// //         return -1;
// //     }

// //     int deviceCount;
// //     cudaGetDeviceCount(&deviceCount);
// //     printf("Number of devices: %d\n", deviceCount);
// //     if (deviceCount == 0) {
// //         printf("No CUDA-capable devices found.\n");
// //         return -1;
// //     }
// //     printf("maxThreasPerBlock = %d, sharedMemPerBlock = %d\n", prop.maxThreadsPerBlock, prop.sharedMemPerBlock);

// //     cudaMalloc((void**)&Dist_dev, n * n * sizeof(int));
// //     cudaMemcpy(Dist_dev, Dist_host,  n * n * sizeof(int), cudaMemcpyHostToDevice);

// //     // dim3 threadsPerBlock(32, 32);
// //     // dim3 grid(ceil(n / float(threadsPerBlock.x)), ceil(n / float(threadsPerBlock.y)));
// //     // block_FW<<<grid, threadsPerBlock>>>(Dist_host, Dist_dev, B);

// //     block_FW(Dist_dev, B);

// //     cudaMemcpy(Dist_host, Dist_dev,  n * n * sizeof(int), cudaMemcpyDeviceToHost);
// //     output(argv[2]);
// //     return 0;
// // }

#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>
#include <device_launch_parameters.h>


#define INF ((1 << 30) - 1)
#define V 50010
#define DEV_NO 0
cudaDeviceProp prop;

int n, m;
int* Dist_host;
int* Dist_res;

void input(char* infile) {
    FILE* file = fopen(infile, "rb");
    fread(&n, sizeof(int), 1, file);
    fread(&m, sizeof(int), 1, file);
    Dist_host = (int*)malloc(n * n * sizeof(int));

    for (int i = 0; i < n * n; ++i) {
        Dist_host[i] = INF;
    }
    for (int i = 0; i < n; ++i) {
        Dist_host[i * n + i] = 0;
    }

    int pair[3];
    for (int i = 0; i < m; ++i) {
        fread(pair, sizeof(int), 3, file);
        Dist_host[pair[0] * n + pair[1]] = pair[2];
    }
    fclose(file);
}

void output(char* outFileName) {
    FILE* outfile = fopen(outFileName, "w");
    for (int i = 0; i < n; ++i) {
        fwrite(&Dist_res[i * n], sizeof(int), n, outfile);
    }
    fclose(outfile);
}

int ceil_div(int a, int b) { return (a + b - 1) / b; }

__global__ void phase1(int* Dist, int n, int B, int Round) {
    extern __shared__ int shared_mem[];
    int x = threadIdx.y;
    int y = threadIdx.x;

    int i = Round * B + x;
    int j = Round * B + y;

    if (i < n && j < n) {
        shared_mem[x * B + y] = Dist[i * n + j];
    } else {
        shared_mem[x * B + y] = INF;
    }
    __syncthreads();

    for (int k = 0; k < B && Round * B + k < n; ++k) {
        if (shared_mem[x * B + k] + shared_mem[k * B + y] < shared_mem[x * B + y]) {
            shared_mem[x * B + y] = shared_mem[x * B + k] + shared_mem[k * B + y];
        }
        __syncthreads();
    }

    if (i < n && j < n) {
        Dist[i * n + j] = shared_mem[x * B + y];
    }
}

__global__ void phase2_row(int* Dist, int n, int B, int Round) {
    if (blockIdx.x == Round) return; // Skip the pivot block

    extern __shared__ int shared_mem[];

    int x = threadIdx.y;
    int y = threadIdx.x;

    // Shared memory partitioning
    int* shared_pivot_row = shared_mem;           // Size B*B
    int* shared_current_row = shared_mem + B * B; // Size B*B

    // Compute coordinates
    int i = Round * B + x;
    int j = blockIdx.x * B + y;

    // Load pivot row
    if (i < n && Round * B + y < n) {
        shared_pivot_row[x * B + y] = Dist[i * n + Round * B + y];
    } else {
        shared_pivot_row[x * B + y] = INF;
    }

    // Load current row block
    if (i < n && j < n) {
        shared_current_row[x * B + y] = Dist[i * n + j];
    } else {
        shared_current_row[x * B + y] = INF;
    }
    __syncthreads();

    for (int k = 0; k < B && Round * B + k < n; ++k) {
        int tmp = shared_pivot_row[x * B + k] + shared_current_row[k * B + y];
        if (tmp < shared_current_row[x * B + y]) {
            shared_current_row[x * B + y] = tmp;
        }
        __syncthreads();
    }

    if (i < n && j < n) {
        Dist[i * n + j] = shared_current_row[x * B + y];
    }
}

__global__ void phase2_col(int* Dist, int n, int B, int Round) {
    if (blockIdx.y == Round) return; // Skip the pivot block

    extern __shared__ int shared_mem[];

    int x = threadIdx.y;
    int y = threadIdx.x;

    // Shared memory partitioning
    int* shared_pivot_col = shared_mem;           // Size B*B
    int* shared_current_col = shared_mem + B * B; // Size B*B

    // Compute coordinates
    int i = blockIdx.y * B + x;
    int j = Round * B + y;

    // Load pivot column
    if (Round * B + x < n && j < n) {
        shared_pivot_col[x * B + y] = Dist[(Round * B + x) * n + j];
    } else {
        shared_pivot_col[x * B + y] = INF;
    }

    // Load current column block
    if (i < n && j < n) {
        shared_current_col[x * B + y] = Dist[i * n + j];
    } else {
        shared_current_col[x * B + y] = INF;
    }
    __syncthreads();

    for (int k = 0; k < B && Round * B + k < n; ++k) {
        int tmp = shared_current_col[x * B + k] + shared_pivot_col[k * B + y];
        if (tmp < shared_current_col[x * B + y]) {
            shared_current_col[x * B + y] = tmp;
        }
        __syncthreads();
    }

    if (i < n && j < n) {
        Dist[i * n + j] = shared_current_col[x * B + y];
    }
}

__global__ void phase3(int* Dist, int n, int B, int Round) {
    if (blockIdx.x == Round || blockIdx.y == Round) return; // Skip pivot row and column

    extern __shared__ int shared_mem[];

    int x = threadIdx.y;
    int y = threadIdx.x;

    // Shared memory partitioning
    int* shared_row = shared_mem;                    // Size B*B
    int* shared_col = shared_mem + B * B;            // Size B*B

    // Compute coordinates
    int i = blockIdx.y * B + x;
    int j = blockIdx.x * B + y;

    // Load row block
    if (i < n && Round * B + y < n) {
        shared_row[x * B + y] = Dist[i * n + Round * B + y];
    } else {
        shared_row[x * B + y] = INF;
    }

    // Load column block
    if (Round * B + x < n && j < n) {
        shared_col[x * B + y] = Dist[(Round * B + x) * n + j];
    } else {
        shared_col[x * B + y] = INF;
    }

    // Get current element
    int temp;
    if (i < n && j < n) {
        temp = Dist[i * n + j];
    } else {
        temp = INF;
    }
    __syncthreads();

    for (int k = 0; k < B && Round * B + k < n; ++k) {
        int via = shared_row[x * B + k] + shared_col[k * B + y];
        if (via < temp) {
            temp = via;
        }
    }

    if (i < n && j < n) {
        Dist[i * n + j] = temp;
    }
}

void block_FW(int* Dist_dev, int B) {
    int round = ceil_div(n, B);
    dim3 block(B, B);
    size_t shared_size_phase1 = sizeof(int) * B * B;
    size_t shared_size_phase2 = sizeof(int) * B * B * 2;
    size_t shared_size_phase3 = sizeof(int) * B * B * 2;

    for (int r = 0; r < round; ++r) {
        // Phase 1
        dim3 grid_phase1(1, 1);
        phase1<<<grid_phase1, block, shared_size_phase1>>>(Dist_dev, n, B, r);
        cudaDeviceSynchronize();

        // Phase 2 (Row)
        dim3 grid_phase2_row(round, 1);
        phase2_row<<<grid_phase2_row, block, shared_size_phase2>>>(Dist_dev, n, B, r);
        cudaDeviceSynchronize();

        // Phase 2 (Column)
        dim3 grid_phase2_col(1, round);
        phase2_col<<<grid_phase2_col, block, shared_size_phase2>>>(Dist_dev, n, B, r);
        cudaDeviceSynchronize();

        // Phase 3
        dim3 grid_phase3(round, round);
        phase3<<<grid_phase3, block, shared_size_phase3>>>(Dist_dev, n, B, r);
        cudaDeviceSynchronize();
    }
}

int main(int argc, char* argv[]) {
    input(argv[1]);
    int B = 32;

    cudaGetDeviceProperties(&prop, DEV_NO);
    printf("maxThreasPerBlock = %d, sharedMemPerBlock = %d\n", prop.maxThreadsPerBlock, prop.sharedMemPerBlock);

    int* Dist_dev;
    Dist_res = (int*)malloc(n * n * sizeof(int));

    cudaMalloc((void**)&Dist_dev, n * n * sizeof(int));
    cudaMemcpy(Dist_dev, Dist_host, n * n * sizeof(int), cudaMemcpyHostToDevice);

    block_FW(Dist_dev, B);

    cudaMemcpy(Dist_res, Dist_dev, n * n * sizeof(int), cudaMemcpyDeviceToHost);
    output(argv[2]);

    cudaFree(Dist_dev);
    free(Dist_host);
    free(Dist_res);
    return 0;
}
